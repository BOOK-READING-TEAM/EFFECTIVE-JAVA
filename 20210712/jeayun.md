
# 오늘 하루 스터디 목차

15. 클래스와 멤버의 접근 권한을 최소하하라
16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
17. 변경 가능성을 최소화하라
18. 상속보다는 컴포지션을 사용하라
19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
20. 추상 클래스보다는 인터페이스를 우선하라
21. 인터페이스는 구현하는 쪽을 생각해 설계하라
22. 인터페이스는 타입을 정의하는 용도로만 사용하라
23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
24. 멤버 클래스는 되도록 static으로 만들라
25. 톱레벨 클래스는 한 파일에 하나만 담으라


## 클래스와 멤버의 접근 권한을 최소하하라

정보은닉, 캡슐화

장점
- 시스템 개발 속도 높임 (병렬로 개발 가능)
- 관리 비용 낮춤 (컴포넌트 빨리 파악 가능, 교체도 부담 적음)
- 성능 자체 높여주는것은 x, 최적화에는 도움을 줌 (해당 컴포터는만 최적화 할 수 있기때문)
- 재사용성을 높임 (외부 의존 x)
- 제작 난이도 낮춰줌 (개별 검증 가능)

기본 원칙은 : 모든클래스와 멤버의 접근성을 가능한 좁혀라

실천하기 좋은 방법 처음에 선언은 무조건 private 필드로 선언.
public으로 올리려면 이유가 있어야 한다. (public 선언 시 API가 되므로 평생 관리해줘야함), thread safe하지 않음.

상수의 경우는 public static final 로 공개해도 좋다.

배열은 절대 안됨 final이여도 안에 내용 바꿀수 있음
해결방법 
1. public 배열 private로 선언하고 public은 불변 리스트로 만들기
2. private로 만들고 복사본을 반환하는 public 메서드 만들기 (방어적 복사)

## public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

getter로 접근하자. 
public filed가 좋지 않은 이유는 (API를 변경하지 않고는 표현 방식을 바꿀 수 없다. 필드를 읽을 때 부수적인 행위 불가)
종종 package-private 클래스나 private 중첩 클래스에서는 필드를 노출하는 편이 나을수있다. (우리는 거의 사용안함)

## 변경 가능성을 최소화하라.

클래스를 불변으로 만드려면 5가지 규칙 존재

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스 확장을 못하도록 한다.(클래스를 final로 선언하는것, 모든 생성자를 private를 선언 후 public 정적 팩토리 제공)
(정적팩토리의 경우 유연성 제공, 객체 캐싱 기능 성능 이점 제공가능)

3. 모든 필드를 final로 선언
4. 모든 필드를 private로 선언
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

불변객체의 장점 
1. 스레드 safe, 동기화 할 필요 x
2. 1번의 이유에서 안심하고 공유 가능

불변객체의 단점
1. 값이 다르면 반드시 독립 개체 그래서 가짓수가 많을 때 비용이 큼

String는 불변이지만 String의 가변 동반 클래스는 StringBuilder
String끼리 더하는것보다 StringBuilder로 가변적으로 더한 후 String 으로 반환 (불변)

합당한 이유가 없다면 모든 필드는 private final이 기본.
클래스는 꼭 필요한 경우 아니면 불변

## 상속보다는 컴포지션을 사용하라
상속은 캡슐화를 깨뜨린다.
이해 잘 안됨.
다시 읽어보기

=> 상위 클래스가 상속을 고려하지 않았으면 문제가 될 수 있으니 조심하자.
상속 취약점을 피하려면 컴포지션, 전달을 사용. 혹 래퍼 클래스로 구현 가능시 래퍼 클래스 이용

## 상속을 고려해 설게하고 문서화하라. 그러지 않았다면 상속을 금지하라
상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
상속용으로 설계한 클래스는 배포전에 꼭 하위 클래스를 만들어서 검증해야함.
상속용으로 설계하지 않은 클래스는 상속 금지. 문제가 너무 많음

## 추상 클래스보다는 인터페이스를 우선하라.
인터페이스와 추상클래스의 차이점은 면접에서 종종 등장

가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점. (상속은 한 개만 가능)
인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급받음.

인터페이스의 장점으로는 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
인터페이스는 믹스인 정의에 안성맞춤. 계층구조가 없는 타입 프레임워크를 만들 수 있다.

추상클래스와 인터페이스의 장점을 섞은 추상 골격 구현 클래스를 제공하는 방법도 있다. (템플릿 메서드 패턴)

## 인터페이스는 구현하는 쪽을 생각해 설계하라.
디폴트 메서드가 생겼지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.
디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
결국 디폴트 메서드가 생겼더라도 인터페이스를 설계 할 때는 조심해야함.
릴리즈 후에 결함 수정하는게 가능할 수도 있지만 그럴 가능성에 기대면 안됨.

## 인터페이스는 타입을 정의하는 용도로만 사용하라
상수 인터페이스 안티패턴은 잘못된 사용 예 이거는 내부 구현을 외부에 노출하는 행위. 사용자에게는 의미 없음. 오히려 혼동을 줌.
1. 특정 클래스난 인터페이스에 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가.
2. 열거 타입으로 가능하면 열거 타입
3. 모두 해당이 안된다면 유틸리티 클래스에 담아 공개하기.
 
## 태그 달린 클래스보다는 클래스 계층구조를 활용하라

태그 달린 클래스는 단점이 한 가득
즉 한 필드로 속성 구분해서 쓰는 경우가 태그 달린 클래스
코드 보는게 빠름

## 멤버 클래스는 되도록 static으로 만들라.
이해 잘 안됨 더 봐야함

## 톱레벨 클래스는 한 파일에 하나만 담으라.
한 파일에는 한 개만 담자.


